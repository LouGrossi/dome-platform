import FreeCAD as App
import Part
import Draft
import math
from FreeCAD import Base
import FreeCADGui as Gui
from typing import List, Tuple, Optional, Dict, Any

# Configuration based on state file
DECK_CONFIG = {
    'features': {
        # Core Features
        'platform': True,          # Base platform
        'central_beam': True,      # Central support beam
        'floor_joists': True,      # Floor joists
        'rim_joists': True,        # Perimeter joists
        'cross_bracing': True,     # Metal cross bracing
        'footings': True,          # Concrete footings
        'railing': True,           # Safety railing system
        'skirting': False,          # Ventilated skirting
        
        # Safety Features
        'drainage_holes': True,    # Water drainage system
        'ventilation_gaps': True,  # Under-deck ventilation
        
        # Structural Features
        'dome_support': True,      # Additional reinforcement for dome
        'deep_footings': False,    # 48-inch footings for frost protection
        'beam_reinforcement': True,# Extra beam support
        'joist_reinforcement': True,# Extra joist support
        
        # Additional Features
        'stairs': False,           # Stair system
        'slope': False,            # Platform slope for drainage
        'ada_compliance': True,     # ADA compliance measures
        'geodesic_dome': False,    # Toggle for geodesic dome
        'show_hardware': True,        # Show joist hangers, fasteners, etc.
        'show_blocking': True,        # Show blocking between joists
    },
    
    'platform': {
        'octagonal_diameter': 32 * 304.8,    # 9753.6 mm (32 feet)
        'square_side': 10 * 304.8,           # 3048.0 mm (10 feet)
        'elevation': 18 * 25.4,              # 457.2 mm (18 inches)
        'board_thickness': 1.5 * 25.4        # 38.1 mm (1.5 inches)
    },
    
    'structural': {
        'central_beam': {
            'width': 4 * (1.5 * 25.4),       # 152.4 mm (4x 1.5 inch boards - quadruple 2x8)
            'height': 7.25 * 25.4,           # 184.15 mm (7.25 inches - standard 2x8)
            'reinforced': True
        },
        'floor_joists': {
            'width': 1.5 * 25.4,             # 38.1 mm (1.5 inches)
            'height': 7.25 * 25.4,           # 184.15 mm (7.25 inches - standard 2x8)
            'spacing': 12 * 25.4,            # 304.8 mm (12 inches OC - tighter spacing for strength)
            'reinforced': True
        },
        'cross_bracing': {
            'spacing': 32 * 25.4,            # 812.8 mm (32 inches - increased frequency)
            'material': 'metal'              # Using metal for better rigidity
        },
        'rim_joists': {
            'width': 1.5 * 25.4,             # 38.1 mm (1.5 inches)
            'height': 7.25 * 25.4            # 184.15 mm (7.25 inches - standard 2x8)
        }
    },
    
    'materials': {
        'wood_color': (0.85, 0.75, 0.60),      # Light wood color (RGB)
        'metal_color': (0.70, 0.70, 0.70),      # Steel gray color (RGB)
        'concrete_color': (0.80, 0.80, 0.80)    # Light gray color (RGB)
    },
    
    'footings': {
        'base_diameter': 16 * 25.4,          # 406.4 mm (16 inches)
        'post_diameter': 8 * 25.4,           # 203.2 mm (8 inches)
        'depth': 36 * 25.4,                  # 914.4 mm (36 inches)
        'max_spacing': 4 * 304.8,            # 1219.2 mm (4 feet - reduced spacing)
        'min_spacing': 3 * 304.8,            # 914.4 mm (3 feet - reduced spacing)
        'edge_margin': 2 * 304.8             # 609.6 mm (2 feet)
    },
    
    'railing': {
        'height': 36 * 25.4,                 # 914.4 mm (36 inches - residential height)
        'post_size': 4 * 25.4,               # 101.6 mm (4 inches)
        'rail_width': 2 * 25.4,              # 50.8 mm (2 inches)
        'rail_height': 4 * 25.4,             # 101.6 mm (4 inches)
        'picket_size': 2 * 25.4,             # 50.8 mm (2 inches)
        'picket_spacing': 4 * 25.4           # 101.6 mm (4 inches)
    },
    
    'skirting': {
        'ventilation_gap': 0.125 * 25.4,     # 3.175 mm (1/8 inch)
        'lattice_spacing': 2 * 25.4,         # 50.8 mm (2 inches)
        'height': 16.5 * 25.4                # 419.1 mm (16.5 inches - adjusted for elevation)
    },
    
    'dome': {
        'diameter': 21 * 304.8,    # 21 feet (matching platform)
        'frequency': 3,            # 3V geodesic dome
        'strut_diameter': 2 * 25.4,# 2-inch tube diameter
        'height_factor': 0.95,     # Slightly less than hemisphere
        'color': (0.7, 0.7, 0.8)   # Light metallic blue
    },
    
    'beam_support': {                        # New configuration section
        'post_spacing': 4 * 304.8,           # 1219.2 mm (4 feet between posts)
        'additional_beams': [                # Additional support beams
            {'offset': -6 * 304.8},          # -6 feet from center (reduced from 8)
            {'offset': 6 * 304.8}            # 6 feet from center (reduced from 8)
        ]
    },
    
    'decking': {
        'board_type': '2x8',
        'board_width': 7.25 * 25.4,      # 184.15 mm (7.25 inches)
        'board_thickness': 1.5 * 25.4,    # 38.1 mm (1.5 inches)
        'gap': 0.125 * 25.4,             # 3.175 mm (1/8 inch)
        'orientation': 'perpendicular',   # 'perpendicular' or 'parallel' to house
        'pattern': 'standard',           # 'standard' or 'alternating'
        'fasteners': {
            'show': True,
            'type': 'deck_screw',
            'size': 3,                    # 3 inch deck screws
            'spacing': 12 * 25.4          # 304.8 mm (12 inches)
        }
    },
    
    'hardware': {
        'joist_hangers': {
            'show': True,
            'type': 'double_shear',
            'thickness': 0.125 * 25.4     # 3.175 mm (1/8 inch)
        },
        'post_brackets': {
            'show': True,
            'type': 'adjustable',
            'thickness': 0.25 * 25.4      # 6.35 mm (1/4 inch)
        },
        'beam_brackets': {
            'show': True,
            'type': 'heavy_duty',
            'thickness': 0.25 * 25.4      # 6.35 mm (1/4 inch)
        }
    }
}

class DeckBuilder:
    """Deck Builder class implementing all features from the state file"""
    def __init__(self):
        """Initialize deck builder with configuration from state file"""
        try:
            self.doc = App.activeDocument()
            self.created_objects = []
            self.platform = None
            self.config = DECK_CONFIG
            self.features = self.config['features']
            self.platform_config = self.config['platform']
            self.structural_config = self.config['structural']
            self.materials = self.config['materials']
            
            # Validate feature configuration
            self._validate_feature_config()
            
            # Clean up existing objects
            self._cleanup_existing_objects()
            
            print("Deck builder initialized successfully")
            
        except Exception as e:
            print(f"Initialization failed: {str(e)}")
            raise

    def _validate_feature_config(self):
        """Validate feature configuration and adjust settings as needed"""
        try:
            # Check for conflicting features
            if self.features['stairs'] and not self.features['railing']:
                print("Warning: Stairs require railing system. Enabling railing.")
                self.features['railing'] = True
            
            # Adjust footing depth based on frost protection setting
            if self.features['deep_footings']:
                self.config['footings']['depth'] = 48 * 25.4  # 48 inches for frost protection
            
            # Validate dome support requirements
            if self.features['dome_support']:
                self.features['beam_reinforcement'] = True
                self.features['joist_reinforcement'] = True
                
        except Exception as e:
            print(f"Feature validation failed: {str(e)}")
            raise

    def _cleanup_existing_objects(self) -> None:
        """Remove all existing deck objects from the document"""
        try:
            num_objects = len(self.doc.Objects)
            print(f"Cleaning up {num_objects} existing objects...")
            objects_to_remove = []
            
            # Collect all objects that match our naming patterns
            for obj in self.doc.Objects:
                if any(obj.Name.startswith(prefix) for prefix in [
                    "Deck_", "Platform", "Beam_", "Support_", "Joist_",
                    "Brace_", "Footing_", "Post_", "Rail_", "Picket_",
                    "Blocking_", "Fastener_", "Hanger_", "PostBracket_",
                    "BeamBracket_", "Parts_List"
                ]):
                    objects_to_remove.append(obj)
            
            # Remove collected objects
            if objects_to_remove:
                # First remove any dependencies
                for obj in objects_to_remove:
                    if hasattr(obj, 'InList'):
                        for parent in obj.InList:
                            if parent in self.doc.Objects:
                                self.doc.removeObject(parent.Name)
                
                # Then remove the objects themselves
                for obj in objects_to_remove:
                    if obj.Name in self.doc.Objects:
                        self.doc.removeObject(obj.Name)
            
            # Force recompute and update view
            self.doc.recompute()
            if Gui.ActiveDocument and Gui.ActiveDocument.ActiveView:
                Gui.SendMsgToActiveView("ViewFit")
            
            # Reset created objects list
            self.created_objects = []
            
            print("Cleanup completed")
            
        except Exception as e:
            print(f"Cleanup failed: {str(e)}")
            raise

    def _create_platform_structure(self) -> None:
        """Create the basic platform structure"""
        try:
            # Create octagonal platform shape
            radius = self.platform_config['octagonal_diameter'] / 2
            angle = math.pi / 8  # 22.5 degrees for octagon
            
            # Create octagon points
            points = []
            for i in range(8):
                current_angle = i * math.pi / 4
                x = radius * math.cos(current_angle)
                y = radius * math.sin(current_angle)
                points.append(Base.Vector(x, y, self.platform_config['elevation']))
                
            # Create face from points
            wire = Part.makePolygon(points + [points[0]])  # Close the polygon
            face = Part.Face(wire)
            
            # Create platform
            platform = face.extrude(Base.Vector(0, 0, self.platform_config['board_thickness']))
            
            # Create platform object
            self.platform = self.doc.addObject("Part::Feature", "Platform")
            self.platform.Shape = platform
            self.platform.ViewObject.ShapeColor = self.materials['wood_color']
            self.platform.ViewObject.Transparency = 80  # Make it semi-transparent
            self.created_objects.append(self.platform)
            
            print("Platform structure created successfully")
            
        except Exception as e:
            print(f"Platform structure creation failed: {str(e)}")
            raise

    def create_platform(self) -> None:
        """Create platform with individual deck boards"""
        try:
            print("Creating platform...")
            
            # Create structural platform (hidden)
            self._create_platform_structure()
            
            # Create individual deck boards
            self.create_deck_boards()
            
            print("Platform created successfully")
            
        except Exception as e:
            print(f"Platform creation failed: {str(e)}")
            raise

    def create_support_structure(self) -> None:
        """Create structural support elements"""
        try:
            print("Creating support structure...")
            
            # Create central beam (cross-beam layout)
            self._create_central_beam()
            
            # Create additional parallel support beams
            self.create_additional_support_beams()
            
            # Create floor joists
            self._create_floor_joists()
            
            # Create cross-bracing
            self._create_cross_bracing()
            
            # Create rim joists
            self._create_rim_joists()
            
            print("Support structure created successfully")
            
        except Exception as e:
            print(f"Support structure creation failed: {str(e)}")
            raise

    def _create_central_beam(self) -> None:
        """Create reinforced central beam"""
        try:
            beam_config = self.structural_config['central_beam']
            
            # Create X-axis beam
            x_beam = Part.makeBox(
                self.platform_config['octagonal_diameter'],
                beam_config['width'],
                beam_config['height'],
                Base.Vector(
                    -self.platform_config['octagonal_diameter']/2,
                    -beam_config['width']/2,
                    self.platform_config['elevation'] - beam_config['height']
                )
            )
            
            # Create Y-axis beam
            y_beam = Part.makeBox(
                beam_config['width'],
                self.platform_config['octagonal_diameter'],
                beam_config['height'],
                Base.Vector(
                    -beam_config['width']/2,
                    -self.platform_config['octagonal_diameter']/2,
                    self.platform_config['elevation'] - beam_config['height']
                )
            )
            
            # Create beam objects
            beam_x = self.doc.addObject("Part::Feature", "Beam_X")
            beam_x.Shape = x_beam
            beam_x.ViewObject.ShapeColor = self.materials['wood_color']
            
            beam_y = self.doc.addObject("Part::Feature", "Beam_Y")
            beam_y.Shape = y_beam
            beam_y.ViewObject.ShapeColor = self.materials['wood_color']
            
            self.created_objects.extend([beam_x, beam_y])
            
        except Exception as e:
            print(f"Central beam creation failed: {str(e)}")
            raise

    def _create_floor_joists(self) -> None:
        """Create floor joists parallel to X-axis"""
        try:
            joist_config = self.structural_config['floor_joists']
            
            # Force recompute to ensure platform is ready
            self.doc.recompute()
            
            # Calculate number of joists based on spacing
            platform_width = self.platform_config['octagonal_diameter']
            num_joists = int(platform_width / joist_config['spacing']) + 1
            
            # Get platform bounds
            platform_bb = self.platform.Shape.BoundBox
            
            # Create a slightly larger bounding box for intersection testing
            test_height = self.platform_config['elevation'] + 100  # Add some margin
            test_box = Part.makeBox(
                platform_bb.XLength + 100,
                platform_bb.YLength + 100,
                test_height,
                Base.Vector(
                    platform_bb.XMin - 50,
                    platform_bb.YMin - 50,
                    0
                )
            )
            
            # Get intersection with platform to find valid area
            platform_area = test_box.common(self.platform.Shape)
            if platform_area.isNull():
                raise ValueError("Could not determine platform area")
            
            # Create joists
            for i in range(num_joists):
                position = -platform_width/2 + (i * joist_config['spacing'])
                
                # Create initial joist
                joist = Part.makeBox(
                    joist_config['width'],
                    platform_bb.YLength + 100,  # Make it longer than needed
                    joist_config['height'],
                    Base.Vector(
                        position - joist_config['width']/2,
                        platform_bb.YMin - 50,
                        self.platform_config['elevation'] - joist_config['height']
                    )
                )
                
                # Project joist footprint onto platform
                projection = Part.makeBox(
                    joist_config['width'],
                    platform_bb.YLength + 100,
                    test_height,
                    Base.Vector(
                        position - joist_config['width']/2,
                        platform_bb.YMin - 50,
                        0
                    )
                )
                
                # Find intersection with platform area
                valid_area = projection.common(platform_area)
                
                if not valid_area.isNull():
                    # Get bounds of valid area
                    valid_bb = valid_area.BoundBox
                    
                    # Create final joist with correct dimensions
                    final_joist = Part.makeBox(
                        joist_config['width'],
                        valid_bb.YLength,
                        joist_config['height'],
                        Base.Vector(
                            position - joist_config['width']/2,
                            valid_bb.YMin,
                            self.platform_config['elevation'] - joist_config['height']
                        )
                    )
                    
                    joist_obj = self.doc.addObject("Part::Feature", f"Joist_{i}")
                    joist_obj.Shape = final_joist
                    joist_obj.ViewObject.ShapeColor = self.materials['wood_color']
                    self.created_objects.append(joist_obj)
            
            # Final recompute
            self.doc.recompute()
                
        except Exception as e:
            print(f"Floor joist creation failed: {str(e)}")
            raise

    def _create_cross_bracing(self) -> None:
        """Create metal cross-bracing between joists"""
        try:
            brace_config = self.structural_config['cross_bracing']
            joist_height = self.structural_config['floor_joists']['height']
            
            # Get platform bounds
            platform_bb = self.platform.Shape.BoundBox
            
            # Calculate number of braces based on spacing
            platform_width = min(platform_bb.XLength, platform_bb.YLength)
            num_braces = int(platform_width / brace_config['spacing'])
            
            # Create a trimming box that represents the platform volume
            trim_box = Part.makeBox(
                platform_bb.XLength,
                platform_bb.YLength,
                joist_height,
                Base.Vector(
                    platform_bb.XMin,
                    platform_bb.YMin,
                    self.platform_config['elevation'] - joist_height
                )
            )
            
            # Get the platform shape for trimming
            platform_shape = self.platform.Shape
            
            for i in range(num_braces):
                start_pos = -platform_width/2 + (i * brace_config['spacing'])
                
                # Create test box for intersection
                test_box = Part.makeBox(
                    brace_config['spacing'],
                    brace_config['spacing'],
                    10,
                    Base.Vector(
                        start_pos,
                        platform_bb.YMin,
                        self.platform_config['elevation'] - joist_height
                    )
                )
                
                # Check intersection with platform
                intersection = test_box.common(platform_shape)
                if not intersection.isNull():
                    # Create X-pattern bracing only where platform exists
                    for direction in [-1, 1]:
                        # Calculate diagonal length based on spacing
                        diagonal_length = brace_config['spacing'] * 1.414  # √2 * spacing
                        
                        # Create initial brace
                        brace = Part.makeBox(
                            diagonal_length,  # length
                            50.8,            # width (2 inches)
                            3.175,           # height (1/8 inch thickness)
                            Base.Vector(
                                start_pos - diagonal_length/2,
                                -25.4,
                                self.platform_config['elevation'] - joist_height/2
                            )
                        )
                        
                        # Rotate for diagonal
                        angle = 45 * direction
                        rotation_center = Base.Vector(
                            start_pos,
                            0,
                            self.platform_config['elevation'] - joist_height/2
                        )
                        brace.rotate(rotation_center, Base.Vector(0, 0, 1), angle)
                        
                        # Trim brace to platform bounds
                        trimmed_brace = brace.common(trim_box)
                        
                        # Only create the brace if it has valid geometry after trimming
                        if not trimmed_brace.isNull() and trimmed_brace.Volume > 0:
                            brace_obj = self.doc.addObject("Part::Feature", f"Brace_{len(self.created_objects)}")
                            brace_obj.Shape = trimmed_brace
                            brace_obj.ViewObject.ShapeColor = self.materials['metal_color']
                            self.created_objects.append(brace_obj)
            
            # Force recompute after creating all braces
            self.doc.recompute()
                    
        except Exception as e:
            print(f"Cross bracing creation failed: {str(e)}")
            raise

    def _create_rim_joists(self) -> None:
        """Create rim joists around platform perimeter"""
        try:
            joist_config = self.structural_config['rim_joists']
            edges = self._detect_platform_edges()
            
            for i, edge in enumerate(edges):
                start = edge.Vertexes[0].Point
                end = edge.Vertexes[1].Point
                
                # Calculate joist dimensions
                length = edge.Length
                direction = end.sub(start).normalize()
                
                # Create rim joist
                joist = Part.makeBox(
                    length,
                    joist_config['width'],
                    joist_config['height'],
                    Base.Vector(
                        start.x,
                        start.y,
                        self.platform_config['elevation'] - joist_config['height']
                    )
                )
                
                # Rotate to align with edge
                angle = math.degrees(math.atan2(direction.y, direction.x))
                joist.rotate(
                    Base.Vector(start.x, start.y, self.platform_config['elevation'] - joist_config['height']),
                    Base.Vector(0, 0, 1),
                    angle
                )
                
                rim_joist = self.doc.addObject("Part::Feature", f"RimJoist_{i}")
                rim_joist.Shape = joist
                rim_joist.ViewObject.ShapeColor = self.materials['wood_color']
                self.created_objects.append(rim_joist)
                
        except Exception as e:
            print(f"Rim joist creation failed: {str(e)}")
            raise

    def create_footings(self) -> None:
        """Create footings with specified placement and dimensions"""
        try:
            print("Creating footings...")
            
            footing_config = self.config['footings']
            
            # Calculate footing positions
            positions = self._calculate_footing_positions()
            
            for i, pos in enumerate(positions):
                # Create base cylinder
                base = Part.makeCylinder(
                    footing_config['base_diameter']/2,
                    footing_config['depth'],
                    Base.Vector(pos.x, pos.y, -footing_config['depth']),
                    Base.Vector(0,0,1)
                )
                
                # Create post cylinder
                post = Part.makeCylinder(
                    footing_config['post_diameter']/2,
                    self.platform_config['elevation'],
                    Base.Vector(pos.x, pos.y, 0),
                    Base.Vector(0,0,1)
                )
                
                # Combine base and post
                footing = base.fuse(post)
                
                # Create footing object
                footing_obj = self.doc.addObject("Part::Feature", f"Footing_{i}")
                footing_obj.Shape = footing
                footing_obj.ViewObject.ShapeColor = self.materials['concrete_color']
                
                self.created_objects.append(footing_obj)
                
            print("Footings created successfully")
            
        except Exception as e:
            print(f"Footing creation failed: {str(e)}")
            raise

    def create_railing(self) -> None:
        """Create railing system with posts, rails, and pickets"""
        try:
            print("Creating railing system...")
            
            railing_config = self.config['railing']
            
            # Get platform vertices for posts
            vertices = self._get_platform_vertices()
            
            # Create posts at vertices
            for i, vertex in enumerate(vertices):
                post = Part.makeBox(
                    railing_config['post_size'],
                    railing_config['post_size'],
                    railing_config['height'],
                    Base.Vector(
                        vertex.x - railing_config['post_size']/2,
                        vertex.y - railing_config['post_size']/2,
                        self.platform_config['elevation']
                    )
                )
                
                post_obj = self.doc.addObject("Part::Feature", f"Post_{i}")
                post_obj.Shape = post
                post_obj.ViewObject.ShapeColor = self.materials['wood_color']
                self.created_objects.append(post_obj)
            
            # Create horizontal rails and pickets
            self._create_rails_and_pickets(vertices)
            
            print("Railing system created successfully")
            
        except Exception as e:
            print(f"Railing creation failed: {str(e)}")
            raise

    def create_skirting(self) -> None:
        """Create skirting with ventilation gaps"""
        try:
            print("Creating skirting...")
            
            skirting_config = self.config['skirting']
            
            # Get platform perimeter
            edges = self._get_outer_edges()
            
            for i, edge in enumerate(edges):
                # Create skirting panel with gaps
                panel = self._create_ventilated_panel(edge, skirting_config)
                
                panel_obj = self.doc.addObject("Part::Feature", f"Skirting_{i}")
                panel_obj.Shape = panel
                panel_obj.ViewObject.ShapeColor = self.materials['wood_color']
                self.created_objects.append(panel_obj)
                
            print("Skirting created successfully")
            
        except Exception as e:
            print(f"Skirting creation failed: {str(e)}")
            raise

    def _validate_platform_intersection(self, shape: Part.Shape) -> bool:
        """Check if a shape intersects with the platform"""
        try:
            if not hasattr(self, 'platform') or not self.platform:
                return False
            return not shape.common(self.platform.Shape).isNull()
        except Exception as e:
            print(f"Platform intersection check failed: {str(e)}")
            return False

    def _is_point_inside_platform(self, point: Base.Vector, margin: float = 304.8) -> bool:
        """Check if a point is inside the platform shape with margin"""
        try:
            if not hasattr(self, 'platform') or not self.platform:
                return False
            
            # Create a 2D point for checking
            point_2d = Base.Vector(point.x, point.y, self.platform_config['elevation'])
            
            # Get the top face of the platform
            top_face = None
            for face in self.platform.Shape.Faces:
                if face.normalAt(0, 0).z > 0:  # Top face
                    top_face = face
                    break
            
            if top_face:
                # Create a test point slightly above the platform
                test_point = Base.Vector(point.x, point.y, self.platform_config['elevation'] + 1)
                
                # Check if point projects onto face
                try:
                    uv = top_face.Surface.parameter(test_point)
                    return top_face.isInside(uv[0], uv[1], margin)
                except:
                    return False
            
            return False
            
        except Exception as e:
            print(f"Point inside check failed: {str(e)}")
            return False

    def _validate_minimum_spacing(self, positions: List[Base.Vector], min_spacing: float) -> List[Base.Vector]:
        """Enforce minimum spacing between positions"""
        try:
            filtered_positions = []
            for pos in positions:
                too_close = False
                for existing_pos in filtered_positions:
                    distance = pos.sub(existing_pos).Length
                    if distance < min_spacing:
                        too_close = True
                        break
                if not too_close:
                    filtered_positions.append(pos)
            return filtered_positions
            
        except Exception as e:
            print(f"Minimum spacing validation failed: {str(e)}")
            return []

    def _detect_platform_edges(self) -> List[Part.Edge]:
        """Detect platform edges for railing placement"""
        try:
            edges = []
            top_z = self.platform_config['elevation'] + self.platform_config['board_thickness']
            
            for edge in self.platform.Shape.Edges:
                # Check if edge is on the top face
                if abs(edge.Vertexes[0].Point.z - top_z) < 0.1 and \
                   abs(edge.Vertexes[1].Point.z - top_z) < 0.1:
                    if self._is_outer_edge(edge):
                        edges.append(edge)
            
            return edges
            
        except Exception as e:
            print(f"Edge detection failed: {str(e)}")
            return []

    def _is_outer_edge(self, edge: Part.Edge) -> bool:
        """Check if an edge is on the outer perimeter"""
        try:
            # Count connected faces
            connected_faces = 0
            for face in self.platform.Shape.Faces:
                for e in face.Edges:
                    if e.isSame(edge):
                        connected_faces += 1
            
            # Outer edges have exactly one connected face
            return connected_faces == 1
            
        except Exception as e:
            print(f"Outer edge check failed: {str(e)}")
            return False

    def _validate_structural_integrity(self) -> bool:
        """Validate structural components"""
        try:
            # Check platform existence
            if not hasattr(self, 'platform') or not self.platform:
                print("Validation failed: Platform not created")
                return False

            # Check central beam
            if not any(obj.Name.startswith("Beam_") for obj in self.created_objects):
                print("Validation failed: Central beam not created")
                return False

            # Check joists
            if not any(obj.Name.startswith("Joist_") for obj in self.created_objects):
                print("Validation failed: Floor joists not created")
                return False

            # Check footings
            if self.features['footings'] and not any(obj.Name.startswith("Footing_") for obj in self.created_objects):
                print("Validation failed: Footings not created")
                return False

            return True

        except Exception as e:
            print(f"Structural validation failed: {str(e)}")
            return False

    def _create_octagonal_platform(self) -> Part.Feature:
        """Create octagonal platform shape"""
        try:
            diameter = self.platform_config['octagonal_diameter']
            thickness = self.platform_config['board_thickness']
            elevation = self.platform_config['elevation']
            
            # Create regular octagon
            polygon = Part.makePolygon([
                Base.Vector(diameter/2 * math.cos(i * math.pi/4),
                          diameter/2 * math.sin(i * math.pi/4),
                          elevation)
                for i in range(8)
            ] + [Base.Vector(diameter/2, 0, elevation)])  # Close the polygon
            
            # Create face from polygon
            face = Part.Face(Part.Wire(polygon))
            
            # Extrude to create platform
            platform = face.extrude(Base.Vector(0, 0, thickness))
            
            # Create platform object
            octagon = self.doc.addObject("Part::Feature", "Octagon")
            octagon.Shape = platform
            octagon.ViewObject.ShapeColor = self.materials['wood_color']
            
            return octagon
            
        except Exception as e:
            print(f"Octagonal platform creation failed: {str(e)}")
            raise

    def _create_square_platform(self) -> Part.Feature:
        """Create square platform shape"""
        try:
            side = self.platform_config['square_side']
            thickness = self.platform_config['board_thickness']
            elevation = self.platform_config['elevation']
            
            # Create square platform
            platform = Part.makeBox(
                side,
                side,
                thickness,
                Base.Vector(-side/2, -side/2, elevation)
            )
            
            # Create platform object
            square = self.doc.addObject("Part::Feature", "Square")
            square.Shape = platform
            square.ViewObject.ShapeColor = self.materials['wood_color']
            
            return square
            
        except Exception as e:
            print(f"Square platform creation failed: {str(e)}")
            raise

    def _calculate_footing_positions(self) -> List[Base.Vector]:
        """Calculate footing positions based on platform shape"""
        try:
            positions = []
            footing_config = self.config['footings']
            
            # Get platform dimensions
            platform_width = self.platform_config['octagonal_diameter']
            
            # Calculate grid spacing
            max_spacing = footing_config['max_spacing']
            min_spacing = footing_config['min_spacing']
            edge_margin = footing_config['edge_margin']
            
            # Create grid of positions
            x_spans = max(2, math.ceil(platform_width / max_spacing))
            y_spans = x_spans  # Square grid for octagonal platform
            
            x_spacing = platform_width / x_spans
            y_spacing = platform_width / y_spans
            
            # Generate grid positions
            for i in range(-x_spans, x_spans + 1):
                for j in range(-y_spans, y_spans + 1):
                    x = i * x_spacing
                    y = j * y_spacing
                    point = Base.Vector(x, y, 0)
                    
                    # Check if point is inside platform boundary
                    if self._is_point_inside_platform(point, edge_margin):
                        positions.append(point)
            
            # Add center support
            positions.append(Base.Vector(0, 0, 0))
            
            # Add octagon vertex supports
            radius = (platform_width / 2) - edge_margin
            for i in range(8):
                angle = i * math.pi / 4
                x = radius * math.cos(angle)
                y = radius * math.sin(angle)
                point = Base.Vector(x, y, 0)
                positions.append(point)
            
            # Filter positions to maintain minimum spacing
            positions = self._validate_minimum_spacing(positions, min_spacing)
            
            print(f"Created {len(positions)} footing positions")
            return positions
            
        except Exception as e:
            print(f"Footing position calculation failed: {str(e)}")
            return []

    def _get_platform_vertices(self) -> List[Base.Vector]:
        """Get platform vertices for railing posts"""
        try:
            if not hasattr(self, 'platform') or not self.platform:
                return []
            
            vertices = []
            top_z = self.platform_config['elevation'] + self.platform_config['board_thickness']
            
            # Get unique vertices from the platform's top face
            for face in self.platform.Shape.Faces:
                if abs(face.normalAt(0, 0).z - 1.0) < 0.1:  # Top face
                    for vertex in face.Vertexes:
                        # Check if vertex is on the outer edge
                        if self._is_outer_vertex(vertex):
                            # Create new vector to ensure hashability
                            pos = Base.Vector(vertex.X, vertex.Y, vertex.Z)
                            if not any(self._vectors_equal(pos, v) for v in vertices):
                                vertices.append(pos)
            
            return vertices
            
        except Exception as e:
            print(f"Platform vertices detection failed: {str(e)}")
            return []

    def _vectors_equal(self, v1: Base.Vector, v2: Base.Vector, tolerance: float = 0.1) -> bool:
        """Compare two vectors with tolerance"""
        return (abs(v1.x - v2.x) < tolerance and 
                abs(v1.y - v2.y) < tolerance and 
                abs(v1.z - v2.z) < tolerance)

    def _is_outer_vertex(self, vertex: Part.Vertex) -> bool:
        """Check if a vertex is on the outer edge of the platform"""
        try:
            # Count number of edges connected to this vertex
            edge_count = 0
            for edge in self.platform.Shape.Edges:
                if (edge.Vertexes[0].Point - vertex.Point).Length < 0.1 or \
                   (edge.Vertexes[1].Point - vertex.Point).Length < 0.1:
                    edge_count += 1
            
            # Outer vertices have fewer connected edges
            return edge_count <= 4
            
        except Exception as e:
            print(f"Outer vertex check failed: {str(e)}")
            return False

    def _create_rails_and_pickets(self, vertices: List[Base.Vector]) -> None:
        """Create horizontal rails and pickets between posts"""
        try:
            railing_config = self.config['railing']
            edges = self._detect_platform_edges()
            
            # Create rails
            for edge in edges:
                start = edge.Vertexes[0].Point
                end = edge.Vertexes[1].Point
                length = edge.Length
                direction = end.sub(start).normalize()
                
                # Create three rails (top, middle, bottom)
                heights = [
                    railing_config['height'],                    # Top rail
                    railing_config['height'] * 0.5,             # Middle rail
                    railing_config['height'] * 0.15             # Bottom rail
                ]
                
                for i, height in enumerate(heights):
                    rail = Part.makeBox(
                        length,
                        railing_config['rail_width'],
                        railing_config['rail_height'],
                        Base.Vector(
                            start.x,
                            start.y - railing_config['rail_width']/2,
                            self.platform_config['elevation'] + height - railing_config['rail_height']/2
                        )
                    )
                    
                    # Rotate rail to align with edge
                    angle = math.degrees(math.atan2(direction.y, direction.x))
                    rail.rotate(
                        Base.Vector(start.x, start.y, self.platform_config['elevation'] + height),
                        Base.Vector(0, 0, 1),
                        angle
                    )
                    
                    rail_obj = self.doc.addObject("Part::Feature", f"Rail_{len(self.created_objects)}")
                    rail_obj.Shape = rail
                    rail_obj.ViewObject.ShapeColor = self.materials['wood_color']
                    self.created_objects.append(rail_obj)
                
                # Create pickets
                picket_spacing = railing_config['picket_spacing']
                num_pickets = int(length / picket_spacing) + 1
                
                for i in range(num_pickets):
                    pos = i * picket_spacing
                    if pos <= length:
                        picket = Part.makeBox(
                            railing_config['picket_size'],
                            railing_config['picket_size'],
                            railing_config['height'] * 0.8,  # Picket height
                            Base.Vector(
                                start.x + direction.x * pos - railing_config['picket_size']/2,
                                start.y + direction.y * pos - railing_config['picket_size']/2,
                                self.platform_config['elevation']
                            )
                        )
                        
                        picket_obj = self.doc.addObject("Part::Feature", f"Picket_{len(self.created_objects)}")
                        picket_obj.Shape = picket
                        picket_obj.ViewObject.ShapeColor = self.materials['wood_color']
                        self.created_objects.append(picket_obj)
            
        except Exception as e:
            print(f"Rails and pickets creation failed: {str(e)}")
            raise

    def _get_outer_edges(self) -> List[Part.Edge]:
        """Get vertical edges for skirting placement"""
        try:
            if not hasattr(self, 'platform') or not self.platform:
                return []
            
            vertical_edges = []
            for edge in self.platform.Shape.Edges:
                # Check if edge is vertical
                v1 = edge.Vertexes[0].Point
                v2 = edge.Vertexes[1].Point
                
                # Edge is vertical if x,y coordinates are the same
                if (abs(v1.x - v2.x) < 0.1 and 
                    abs(v1.y - v2.y) < 0.1 and 
                    abs(v1.z - v2.z) > self.platform_config['elevation'] / 2):
                    
                    if self._is_perimeter_edge(edge):
                        vertical_edges.append(edge)
            
            return vertical_edges
            
        except Exception as e:
            print(f"Vertical edge detection failed: {str(e)}")
            return []

    def _is_perimeter_edge(self, edge: Part.Edge) -> bool:
        """Check if an edge is on the perimeter of the platform"""
        try:
            # Edge is on perimeter if it has only one adjacent face
            return len(edge.Faces) == 1
            
        except Exception as e:
            print(f"Perimeter edge check failed: {str(e)}")
            return False

    def _create_ventilated_panel(self, edge: Part.Edge, config: Dict) -> Part.Shape:
        """Create skirting panel with ventilation gaps"""
        try:
            start = edge.Vertexes[0].Point
            end = edge.Vertexes[1].Point
            height = abs(end.z - start.z)
            width = self.platform_config['board_thickness']
            
            # Create base panel
            panel = Part.makeBox(
                edge.Length + width,  # Add thickness for overlap
                width,
                height,
                Base.Vector(
                    min(start.x, end.x) - width/2,
                    min(start.y, end.y) - width/2,
                    min(start.z, end.z)
                )
            )
            
            # Add ventilation gaps
            gap_size = config['ventilation_gap']
            lattice_spacing = config['lattice_spacing']
            
            # Create ventilation holes
            holes = []
            num_gaps = int(edge.Length / lattice_spacing)
            for i in range(num_gaps):
                pos = i * lattice_spacing
                if pos + gap_size < edge.Length:
                    hole = Part.makeBox(
                        gap_size,
                        width * 2,  # Ensure hole goes through panel
                        height / 3,  # Gap in bottom third for ventilation
                        Base.Vector(
                            min(start.x, end.x) + pos - width/2,
                            min(start.y, end.y) - width,
                            min(start.z, end.z)
                        )
                    )
                    holes.append(hole)
            
            # Cut holes from panel
            for hole in holes:
                panel = panel.cut(hole)
            
            # Rotate panel to align with edge
            if abs(start.x - end.x) > 0.1 or abs(start.y - end.y) > 0.1:
                direction = Base.Vector(end.x - start.x, end.y - start.y, 0).normalize()
                angle = math.degrees(math.atan2(direction.y, direction.x))
                panel.rotate(
                    Base.Vector(start.x, start.y, start.z),
                    Base.Vector(0, 0, 1),
                    angle
                )
            
            return panel
            
        except Exception as e:
            print(f"Ventilated panel creation failed: {str(e)}")
            raise

    def _is_feature_enabled(self, feature_name: str) -> bool:
        """Check if a specific feature is enabled"""
        try:
            return self.features.get(feature_name, False)
        except Exception as e:
            print(f"Feature check failed for {feature_name}: {str(e)}")
            return False

    def _validate_creation(self, obj: Any, name: str) -> bool:
        """Validate that an object was created successfully"""
        try:
            if obj is None:
                print(f"Failed to create {name}")
                return False
            if hasattr(obj, 'Shape') and obj.Shape.isNull():
                print(f"{name} has null shape")
                return False
            return True
        except Exception as e:
            print(f"Validation failed for {name}: {str(e)}")
            return False

    def _validate_object_creation(self, obj: Any, name: str) -> bool:
        """Validate that an object was created successfully"""
        if obj is None:
            print(f"Failed to create {name}")
            return False
            
        if hasattr(obj, 'Shape'):
            if obj.Shape.isNull():
                print(f"{name} has null shape")
                return False
                
            if obj.Shape.Volume < 0.000001:  # Check for zero volume
                print(f"{name} has zero volume")
                return False
                
        return True

    def _log_creation_details(self, component: str, count: int) -> None:
        """Log details about created objects"""
        print(f"Created {count} {component} objects:")
        recent_objects = self.created_objects[-count:]
        for obj in recent_objects:
            if hasattr(obj, 'Shape'):
                print(f"  - {obj.Name}: Volume={obj.Shape.Volume:.2f}, Valid={not obj.Shape.isNull()}")
            else:
                print(f"  - {obj.Name}: No shape information")

    def _get_platform_edges(self) -> List[Part.Edge]:
        """Get all platform edges for component placement"""
        try:
            if not hasattr(self, 'platform') or not self.platform:
                return []
            
            all_edges = []
            top_z = self.platform_config['elevation'] + self.platform_config['board_thickness']
            
            for edge in self.platform.Shape.Edges:
                v1 = edge.Vertexes[0].Point
                v2 = edge.Vertexes[1].Point
                
                # Categorize edge type
                is_vertical = (abs(v1.x - v2.x) < 0.1 and abs(v1.y - v2.y) < 0.1)
                is_top = (abs(v1.z - top_z) < 0.1 and abs(v2.z - top_z) < 0.1)
                
                if (is_vertical or is_top) and self._is_outer_edge(edge):
                    all_edges.append(edge)
            
            return all_edges
            
        except Exception as e:
            print(f"Edge detection failed: {str(e)}")
            return []

    def _validate_component_spacing(self) -> bool:
        """Validate spacing between components"""
        try:
            # Get all component positions
            positions = []
            for obj in self.created_objects:
                if hasattr(obj, 'Shape'):
                    pos = obj.Shape.CenterOfMass
                    positions.append((obj.Name, pos))
            
            # Check minimum spacing between components
            min_spacing = 25.4  # 1 inch minimum spacing
            for i, (name1, pos1) in enumerate(positions):
                for name2, pos2 in positions[i+1:]:
                    distance = pos1.sub(pos2).Length
                    if distance < min_spacing:
                        print(f"Warning: {name1} and {name2} are too close: {distance}mm")
                        return False
            
            return True
            
        except Exception as e:
            print(f"Component spacing validation failed: {str(e)}")
            return False

    def create_geodesic_dome(self) -> None:
        """Create geodesic dome on top of the platform"""
        try:
            if not self.features.get('geodesic_dome', False):
                return
            
            print("Creating geodesic dome...")
            dome_config = self.config['dome']
            
            # Calculate basic dome parameters
            radius = dome_config['diameter'] / 2
            frequency = dome_config['frequency']
            strut_radius = dome_config['strut_diameter'] / 2
            height = radius * dome_config['height_factor']
            
            # Generate icosahedron vertices (normalized)
            phi = (1 + math.sqrt(5)) / 2  # Golden ratio
            norm = math.sqrt(phi * phi + 1)
            
            vertices = [
                (phi/norm, 1/norm, 0), (-phi/norm, 1/norm, 0),
                (phi/norm, -1/norm, 0), (-phi/norm, -1/norm, 0),
                (1/norm, 0, phi/norm), (-1/norm, 0, phi/norm),
                (1/norm, 0, -phi/norm), (-1/norm, 0, -phi/norm),
                (0, phi/norm, 1/norm), (0, -phi/norm, 1/norm),
                (0, phi/norm, -1/norm), (0, -phi/norm, -1/norm)
            ]
            
            # Scale vertices to dome radius
            vertices = [(x*radius, y*radius, z*radius) for x, y, z in vertices]
            
            # Define faces for icosahedron (only upper hemisphere)
            faces = [
                (0, 8, 4), (0, 5, 8), (2, 4, 9),
                (2, 9, 3), (1, 8, 5), (1, 5, 3),
                (0, 4, 2), (1, 3, 5), (0, 2, 8),
                (1, 5, 8)
            ]
            
            def subdivide_triangle(v1, v2, v3, depth):
                if depth == 0:
                    return [(v1, v2, v3)]
                
                # Calculate midpoints
                def midpoint(p1, p2):
                    x = (p1[0] + p2[0])/2
                    y = (p1[1] + p2[1])/2
                    z = (p1[2] + p2[2])/2
                    mid = (x, y, z)
                    # Project to sphere
                    length = math.sqrt(sum(c*c for c in mid))
                    return tuple(c * radius / length for c in mid)
                
                v12 = midpoint(v1, v2)
                v23 = midpoint(v2, v3)
                v31 = midpoint(v3, v1)
                
                return (
                    subdivide_triangle(v1, v12, v31, depth - 1) +
                    subdivide_triangle(v12, v2, v23, depth - 1) +
                    subdivide_triangle(v31, v23, v3, depth - 1) +
                    subdivide_triangle(v12, v23, v31, depth - 1)
                )
            
            # Generate all struts
            struts = set()
            for face in faces:
                triangles = subdivide_triangle(
                    vertices[face[0]],
                    vertices[face[1]],
                    vertices[face[2]],
                    int(math.log2(frequency))
                )
                
                for triangle in triangles:
                    # Only include struts above XY plane
                    if all(v[2] >= 0 for v in triangle):
                        # Add edges as struts (sorted to avoid duplicates)
                        struts.add(tuple(sorted([triangle[0], triangle[1]])))
                        struts.add(tuple(sorted([triangle[1], triangle[2]])))
                        struts.add(tuple(sorted([triangle[2], triangle[0]])))
            
            # Create cylinder for each strut
            elevation = self.platform_config['elevation'] + self.platform_config['board_thickness']
            
            for i, (p1, p2) in enumerate(struts):
                # Adjust height by elevation
                p1_elevated = (p1[0], p1[1], p1[2] + elevation)
                p2_elevated = (p2[0], p2[1], p2[2] + elevation)
                
                # Create vector for cylinder direction
                start = Base.Vector(*p1_elevated)
                direction = Base.Vector(
                    p2_elevated[0] - p1_elevated[0],
                    p2_elevated[1] - p1_elevated[1],
                    p2_elevated[2] - p1_elevated[2]
                )
                length = direction.Length
                
                if length > 0:  # Only create valid struts
                    # Create cylinder
                    cylinder = Part.makeCylinder(
                        strut_radius,
                        length,
                        start,
                        direction
                    )
                    
                    # Create strut object
                    strut = self.doc.addObject("Part::Feature", f"DomeStrut_{i}")
                    strut.Shape = cylinder
                    strut.ViewObject.ShapeColor = dome_config['color']
                    self.created_objects.append(strut)
            
            # Force recompute
            self.doc.recompute()
            print("Geodesic dome created successfully")
            
        except Exception as e:
            print(f"Geodesic dome creation failed: {str(e)}")
            raise

    def create_additional_support_beams(self) -> None:
        """Create additional parallel support beams that stay within platform bounds"""
        try:
            print("Creating additional support beams...")
            beam_config = self.structural_config['central_beam']
            support_config = self.config['beam_support']
            
            # Calculate octagon dimensions
            radius = self.platform_config['octagonal_diameter'] / 2
            angle = math.pi / 8  # 22.5 degrees for octagon
            
            for beam_data in support_config['additional_beams']:
                offset = beam_data['offset']
                
                # Calculate beam length at this offset using octagon geometry
                y = abs(offset)
                if y >= radius * math.cos(angle):
                    print(f"Skipping beam at offset {y/304.8:.1f}' - beyond safe platform bounds")
                    continue
                
                # Calculate safe beam length (80% of theoretical maximum for
                max_length = 2 * (radius * math.cos(angle) - y * math.tan(angle))
                beam_length = 0.8 * max_length  # Add safety margin
                
                if beam_length > 0:
                    # Create X-axis parallel beam
                    beam = Part.makeBox(
                        beam_length,
                        beam_config['width'],
                        beam_config['height'],
                        Base.Vector(
                            -beam_length/2,  # Center the beam
                            -beam_config['width']/2 + offset,
                            self.platform_config['elevation'] - beam_config['height']
                        )
                    )
                    
                    beam_obj = self.doc.addObject("Part::Feature", f"Support_Beam_X_{len(self.created_objects)}")
                    beam_obj.Shape = beam
                    beam_obj.ViewObject.ShapeColor = self.materials['wood_color']
                    self.created_objects.append(beam_obj)
                    print(f"Created support beam at {offset/304.8:.1f}' offset with length {beam_length/304.8:.1f}'")
            
            self.doc.recompute()
            print("Additional support beams created successfully")
            
        except Exception as e:
            print(f"Additional support beam creation failed: {str(e)}")
            raise

    def create_deck_boards(self) -> None:
        """Create individual deck boards with proper spacing and orientation"""
        try:
            print("Creating deck boards...")
            deck_config = self.config['decking']
            
            # Get platform bounds
            platform_bb = self.platform.Shape.BoundBox
            
            # Calculate board dimensions and spacing
            board_width = deck_config['board_width']
            board_thickness = deck_config['board_thickness']
            gap = deck_config['gap']
            
            # Determine orientation and starting point
            is_perpendicular = deck_config['orientation'] == 'perpendicular'
            
            # Create a slightly larger bounding box for intersection testing
            test_box = Part.makeBox(
                platform_bb.XLength + 100,
                platform_bb.YLength + 100,
                board_thickness,
                Base.Vector(
                    platform_bb.XMin - 50,
                    platform_bb.YMin - 50,
                    self.platform_config['elevation']
                )
            )
            
            # Get intersection with platform to find valid area
            platform_area = test_box.common(self.platform.Shape)
            
            # Calculate number of boards needed
            if is_perpendicular:
                span = platform_bb.XLength
                spacing = board_width + gap
                num_boards = int(platform_bb.YLength / spacing) + 1
            else:
                span = platform_bb.YLength
                spacing = board_width + gap
                num_boards = int(platform_bb.XLength / spacing) + 1
            
            # Create boards
            for i in range(num_boards):
                position = -span/2 + (i * spacing)
                
                # Create initial board
                if is_perpendicular:
                    board = Part.makeBox(
                        span + 100,  # Make it longer than needed
                        board_width,
                        board_thickness,
                        Base.Vector(
                            platform_bb.XMin - 50,
                            position,
                            self.platform_config['elevation']
                        )
                    )
                else:
                    board = Part.makeBox(
                        board_width,
                        span + 100,  # Make it longer than needed
                        board_thickness,
                        Base.Vector(
                            position,
                            platform_bb.YMin - 50,
                            self.platform_config['elevation']
                        )
                    )
                
                # Trim board to platform shape
                trimmed_board = board.common(platform_area)
                
                if not trimmed_board.isNull():
                    board_obj = self.doc.addObject("Part::Feature", f"Deck_Board_{i}")
                    board_obj.Shape = trimmed_board
                    board_obj.ViewObject.ShapeColor = self.materials['wood_color']
                    self.created_objects.append(board_obj)
                    
                    # Add fasteners if enabled
                    if deck_config['fasteners']['show']:
                        self._create_board_fasteners(board_obj, i)
            
            self.doc.recompute()
            print("Deck boards created successfully")
            
        except Exception as e:
            print(f"Deck board creation failed: {str(e)}")
            raise

    def _create_board_fasteners(self, board_obj, board_index):
        """Create fasteners for a deck board"""
        try:
            fastener_config = self.config['decking']['fasteners']
            spacing = fastener_config['spacing']
            
            # Get board bounds
            bb = board_obj.Shape.BoundBox
            
            # Calculate fastener positions along board length
            length = max(bb.XLength, bb.YLength)
            num_fasteners = int(length / spacing) + 1
            
            for i in range(num_fasteners):
                position = i * spacing
                
                # Create fastener representation (small cylinder)
                fastener = Part.makeCylinder(
                    2.5,  # 5mm diameter
                    fastener_config['size'] * 25.4,  # Convert inches to mm
                    Base.Vector(
                        bb.XMin + (position if bb.XLength > bb.YLength else bb.XLength/2),
                        bb.YMin + (bb.YLength/2 if bb.XLength > bb.YLength else position),
                        self.platform_config['elevation']
                    )
                )
                
                fastener_obj = self.doc.addObject("Part::Feature", f"Fastener_{board_index}_{i}")
                fastener_obj.Shape = fastener
                fastener_obj.ViewObject.ShapeColor = self.materials['metal_color']
                self.created_objects.append(fastener_obj)
            
        except Exception as e:
            print(f"Fastener creation failed: {str(e)}")
            raise

    def create_hardware(self) -> None:
        """Create joist hangers, post brackets, and beam brackets"""
        try:
            if not self.features.get('show_hardware', False):
                return
            
            print("Creating hardware...")
            hardware_config = self.config['hardware']
            
            # Create joist hangers
            if hardware_config['joist_hangers']['show']:
                self._create_joist_hangers()
            
            # Create post brackets
            if hardware_config['post_brackets']['show']:
                self._create_post_brackets()
            
            # Create beam brackets
            if hardware_config['beam_brackets']['show']:
                self._create_beam_brackets()
            
            print("Hardware created successfully")
            
        except Exception as e:
            print(f"Hardware creation failed: {str(e)}")
            raise

    def _create_joist_hangers(self) -> None:
        """Create joist hangers at beam intersections"""
        try:
            hanger_config = self.config['hardware']['joist_hangers']
            joist_config = self.structural_config['floor_joists']
            
            # Find all joists
            joists = [obj for obj in self.created_objects if obj.Name.startswith("Joist_")]
            beams = [obj for obj in self.created_objects if obj.Name.startswith("Beam_") or 
                    obj.Name.startswith("Support_Beam_")]
            
            # Get platform bounds for validation
            platform_bb = self.platform.Shape.BoundBox
            
            for joist in joists:
                joist_bb = joist.Shape.BoundBox
                
                for beam in beams:
                    beam_bb = beam.Shape.BoundBox
                    
                    # Check if joist intersects beam within platform bounds
                    if (self._objects_intersect(joist, beam) and
                        platform_bb.isInside(beam_bb.Center)):
                        
                        # Create hanger geometry
                        hanger = self._create_hanger_shape(
                            joist_bb,
                            beam_bb,
                            hanger_config['thickness']
                        )
                        
                        # Validate hanger position is within platform
                        hanger_bb = hanger.BoundBox
                        if platform_bb.isInside(hanger_bb.Center):
                            hanger_obj = self.doc.addObject("Part::Feature", f"Hanger_{joist.Name}_{beam.Name}")
                            hanger_obj.Shape = hanger
                            hanger_obj.ViewObject.ShapeColor = self.materials['metal_color']
                            self.created_objects.append(hanger_obj)
                    
        except Exception as e:
            print(f"Joist hanger creation failed: {str(e)}")
            raise

    def create_blocking(self) -> None:
        """Create blocking between joists"""
        try:
            if not self.features.get('show_blocking', False):
                return
            
            print("Creating blocking...")
            joist_config = self.structural_config['floor_joists']
            
            # Find all joists
            joists = [obj for obj in self.created_objects if obj.Name.startswith("Joist_")]
            
            # Create blocking at third points
            for i in range(len(joists) - 1):
                current_joist = joists[i]
                next_joist = joists[i + 1]
                
                # Calculate blocking positions (at thirds)
                bb = current_joist.Shape.BoundBox
                length = bb.YLength
                positions = [length/3, 2*length/3]
                
                for pos in positions:
                    block = Part.makeBox(
                        joist_config['width'],
                        next_joist.Shape.BoundBox.XMin - current_joist.Shape.BoundBox.XMax,
                        joist_config['height'],
                        Base.Vector(
                            current_joist.Shape.BoundBox.XMax,
                            bb.YMin + pos - joist_config['width']/2,
                            bb.ZMin
                        )
                    )
                    
                    block_obj = self.doc.addObject("Part::Feature", f"Blocking_{len(self.created_objects)}")
                    block_obj.Shape = block
                    block_obj.ViewObject.ShapeColor = self.materials['wood_color']
                    self.created_objects.append(block_obj)
                    
            print("Blocking created successfully")
            
        except Exception as e:
            print(f"Blocking creation failed: {str(e)}")
            raise

    def _create_hanger_shape(self, joist_bb, beam_bb, thickness):
        """Create a simplified joist hanger shape"""
        try:
            # Create basic U shape for hanger
            width = joist_bb.XLength + 2 * thickness
            height = joist_bb.ZLength + thickness
            depth = joist_bb.YLength / 4  # Reduce depth to 1/4 of joist length
            
            # Base plate
            base = Part.makeBox(width, depth, height)
            
            # Side plates
            left = Part.makeBox(depth, thickness, height,
                              Base.Vector(0, 0, 0))
            right = Part.makeBox(depth, thickness, height,
                                   Base.Vector(width - depth, 0, 0))
            
            # Combine shapes
            hanger = base.fuse([left, right])
            
            # Position at intersection
            intersection_point = self._get_intersection_point(joist_bb, beam_bb)
            if intersection_point:
                hanger.translate(Base.Vector(
                    joist_bb.XMin - thickness,
                    intersection_point.y - depth/2,
                    joist_bb.ZMin - thickness
                ))
            
            return hanger
            
        except Exception as e:
            print(f"Hanger shape creation failed: {str(e)}")
            raise

    def _get_intersection_point(self, bb1, bb2):
        """Get the intersection point of two bounding boxes"""
        try:
            # Calculate intersection point at center of overlap
            x = max(bb1.XMin, bb2.XMin) + (min(bb1.XMax, bb2.XMax) - max(bb1.XMin, bb2.XMin))/2
            y = max(bb1.YMin, bb2.YMin) + (min(bb1.YMax, bb2.YMax) - max(bb1.YMin, bb2.YMin))/2
            z = max(bb1.ZMin, bb2.ZMin) + (min(bb1.ZMax, bb2.ZMax) - max(bb1.ZMin, bb2.ZMin))/2
            
            return Base.Vector(x, y, z)
            
        except Exception:
            return None

    def _objects_intersect(self, obj1, obj2):
        """Check if two objects intersect"""
        try:
            return not obj1.Shape.common(obj2.Shape).isNull()
        except Exception:
            return False

    def _create_post_brackets(self) -> None:
        """Create brackets for railing posts"""
        try:
            bracket_config = self.config['hardware']['post_brackets']
            thickness = bracket_config['thickness']
            
            # Find all posts
            posts = [obj for obj in self.created_objects if obj.Name.startswith("Post_")]
            
            for post in posts:
                bb = post.Shape.BoundBox
                
                # Create L-shaped bracket
                width = bb.XLength + 2 * thickness
                height = bb.ZLength / 4  # Bracket covers 1/4 of post height
                depth = bb.YLength + 2 * thickness
                
                # Base plate
                base = Part.makeBox(width, depth, thickness)
                
                # Vertical plate
                vertical = Part.makeBox(thickness, depth, height,
                                      Base.Vector(0, 0, 0))
                
                # Combine shapes
                bracket = base.fuse(vertical)
                
                # Position at post base
                bracket.translate(Base.Vector(
                    bb.XMin - thickness,
                    bb.YMin - thickness,
                    self.platform_config['elevation']
                ))
                
                bracket_obj = self.doc.addObject("Part::Feature", f"PostBracket_{post.Name}")
                bracket_obj.Shape = bracket
                bracket_obj.ViewObject.ShapeColor = self.materials['metal_color']
                self.created_objects.append(bracket_obj)
            
        except Exception as e:
            print(f"Post bracket creation failed: {str(e)}")
            raise

    def _create_beam_brackets(self) -> None:
        """Create brackets for beam connections"""
        try:
            bracket_config = self.config['hardware']['beam_brackets']
            thickness = bracket_config['thickness']
            
            # Find beams and support beams
            beams = [obj for obj in self.created_objects 
                    if obj.Name.startswith("Beam_") or 
                    obj.Name.startswith("Support_Beam_")]
            
            for beam in beams:
                bb = beam.Shape.BoundBox
                
                # Create U-shaped bracket
                width = bb.XLength + 2 * thickness
                height = bb.ZLength + thickness
                depth = thickness
                
                # Base plate
                base = Part.makeBox(width, depth, height)
                
                # Side plates
                left = Part.makeBox(depth, bb.YLength/4, height,
                                  Base.Vector(0, 0, 0))
                right = Part.makeBox(depth, bb.YLength/4, height,
                                   Base.Vector(width - depth, 0, 0))
                
                # Combine shapes
                bracket = base.fuse([left, right])
                
                # Create brackets at both ends of beam
                for i, y_pos in enumerate([bb.YMin, bb.YMax - bb.YLength/4]):
                    bracket_copy = bracket.copy()
                    bracket_copy.translate(Base.Vector(
                        bb.XMin - thickness,
                        y_pos,
                        bb.ZMin - thickness
                    ))
                    
                    bracket_obj = self.doc.addObject("Part::Feature", f"BeamBracket_{beam.Name}_{i}")
                    bracket_obj.Shape = bracket_copy
                    bracket_obj.ViewObject.ShapeColor = self.materials['metal_color']
                    self.created_objects.append(bracket_obj)
            
        except Exception as e:
            print(f"Beam bracket creation failed: {str(e)}")
            raise

    def create_parts_list(self) -> None:
        """Create a parts list annotation in the 3D view."""
        try:
            print("Generating parts list...")
            if hasattr(self, 'platform') and self.platform and self.created_objects:
                # Get platform bounds
                platform_bb = self.platform.Shape.BoundBox
                
                # Calculate placement - offset from deck edge by 2 feet
                x_offset = platform_bb.XMax + 609.6  # 24 inches = 609.6mm
                y_offset = platform_bb.YMin  # Align with platform edge
                z_offset = platform_bb.ZMax  # Place at deck height
                
                # Create text content
                text = ["MATERIALS ORDER LIST:", ""]
                for category, items in self._calculate_parts_list().items():
                    text.append(f"{category}:")
                    text.extend(f"  - {item}" for item in items)
                    text.append("")
                
                # Create text using Draft.make_text()
                annotation = Draft.make_text(text, App.Vector(x_offset, y_offset, z_offset))
                
                # Set properties
                annotation.Label = "Parts_List"
                annotation.ViewObject.FontSize = 12
                
                # Add to created objects
                self.created_objects.append(annotation.Name)
                
                # Force recompute
                self.doc.recompute()
                print("Parts list generated successfully")
                
            else:
                print("No platform or parts to list - skipping parts list creation")
                
        except Exception as e:
            print(f"Parts list generation failed: {str(e)}")
            raise

    def _calculate_parts_list(self) -> Dict[str, List[str]]:
        """Calculate list of materials needed for the deck."""
        parts = {
            'Lumber': [],
            'Hardware': [],
            'Concrete': [],
            'Metal': []
        }
        
        # Platform boards
        board_count = len([obj for obj in self.created_objects if obj.Name.startswith('Deck_Board_')])
        parts['Lumber'].append(f"{board_count} - 2x8 Deck Boards @ {self.config['platform']['octagonal_diameter']/304.8:.1f}' length")
        
        # Joists
        joist_count = len([obj for obj in self.created_objects if obj.Name.startswith('Joist_')])
        parts['Lumber'].append(f"{joist_count} - 2x8 Floor Joists @ {self.config['platform']['octagonal_diameter']/304.8:.1f}' length")
        
        # Support beams
        beam_count = len([obj for obj in self.created_objects if obj.Name.startswith('Beam_')])
        support_beam_count = len([obj for obj in self.created_objects if obj.Name.startswith('Support_Beam_')])
        parts['Lumber'].append(f"{beam_count + support_beam_count} - 4x8 Support Beams @ {self.config['platform']['octagonal_diameter']/304.8:.1f}' length")
        
        # Blocking
        blocking_count = len([obj for obj in self.created_objects if obj.Name.startswith('Blocking_')])
        parts['Lumber'].append(f"{blocking_count} - 2x8 Blocking @ 16\" length")
        
        # Posts
        post_count = len([obj for obj in self.created_objects if obj.Name.startswith('Post_')])
        parts['Lumber'].append(f"{post_count} - 4x4 Posts @ {self.config['railing']['height']/25.4:.1f}\" height")
        
        # Hardware
        fastener_count = len([obj for obj in self.created_objects if obj.Name.startswith('Fastener_')])
        parts['Hardware'].append(f"{fastener_count} - Deck Screws")
        
        bracket_count = len([obj for obj in self.created_objects if 'Bracket_' in obj.Name])
        parts['Hardware'].append(f"{bracket_count} - Joist/Beam Brackets")
        
        # Concrete
        footing_count = len([obj for obj in self.created_objects if obj.Name.startswith('Footing_')])
        concrete_volume = footing_count * (math.pi * (self.config['footings']['base_diameter']/2)**2 * 
                                         self.config['footings']['depth']) / (1728 * 25.4**3)  # Convert to cubic yards
        parts['Concrete'].append(f"{footing_count} - Footings ({concrete_volume:.1f} cubic yards total)")
        
        # Metal bracing
        brace_count = len([obj for obj in self.created_objects if obj.Name.startswith('Brace_')])
        parts['Metal'].append(f"{brace_count} - Cross Braces @ 32\" length")
        
        return parts

if __name__ == '__main__':
    try:
        # Initialize the document
        doc = App.activeDocument()
        if doc is None:
            doc = App.newDocument("DeckDesign")
        
        # Create deck builder instance and force cleanup
        deck = DeckBuilder()
        deck._cleanup_existing_objects()  # Force cleanup before building
        
        # Build only enabled components
        features = deck.config['features']
        created_objects = []
        
        if features['platform']:
            print("Creating deck platform...")
            initial_count = len(deck.created_objects)
            deck.create_platform()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Platform objects created: {created_names}")
        
        if any([features['central_beam'], features['floor_joists'], 
               features['rim_joists'], features['cross_bracing']]):
            print("Creating support structure...")
            initial_count = len(deck.created_objects)
            deck.create_support_structure()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Support objects created: {created_names}")
        
        if features['footings']:
            print("Creating footings...")
            initial_count = len(deck.created_objects)
            deck.create_footings()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Footing objects created: {created_names}")
        
        if features['railing']:
            print("Creating railing system...")
            initial_count = len(deck.created_objects)
            deck.create_railing()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Railing objects created: {created_names}")
        
        if features['skirting']:
            print("Creating skirting...")
            initial_count = len(deck.created_objects)
            deck.create_skirting()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Skirting objects created: {created_names}")
        
        if features['geodesic_dome']:
            print("Creating geodesic dome...")
            initial_count = len(deck.created_objects)
            deck.create_geodesic_dome()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Dome objects created: {created_names}")
        
        if features['show_hardware']:
            print("Creating hardware...")
            initial_count = len(deck.created_objects)
            deck.create_hardware()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Hardware objects created: {created_names}")
        
        if features['show_blocking']:
            print("Creating blocking...")
            initial_count = len(deck.created_objects)
            deck.create_blocking()
            created_names = [obj.Name for obj in deck.created_objects[initial_count:]]
            print(f"Blocking objects created: {created_names}")
            
        # Validate construction
        if not deck._validate_structural_integrity():
            print("Warning: Structural validation failed")
        
        # Force final recompute and update
        doc.recompute()
        Gui.SendMsgToActiveView("ViewFit")
        
        print(f"Total objects created: {len(deck.created_objects)}")
        print("Deck creation completed successfully")
        
        # Create parts list after all components
        deck.create_parts_list()
        
    except Exception as e:
        print(f"Deck creation failed: {str(e)}")
        raise
